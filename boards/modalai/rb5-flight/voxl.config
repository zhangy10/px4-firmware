#!/bin/sh
# PX4 commands need the 'px4-' prefix in bash.
# (px4-alias.sh is expected to be in the PATH)
. px4-alias.sh

# Figure out what platform we are running on.

# Eventually there will be a utility called voxl-platform that will
# return the platform tag or an error code. This utility is not yet
# ubiquitous so it may be that it isn't available. Trying to call a
# non existent program will generate an error code by the OS. If the
# program exists and doesn't return an error code then use the results.
PLATFORM=`voxl-platform 2> /dev/null`
RETURNCODE=$?
if [ $RETURNCODE -ne 0 ]; then
    # If we couldn't get the platform from the voxl-platform utility then check
    # /etc/version to see if there is an M0052 substring in the version string. If so,
    # then we assume that we are on M0052. Otherwise assume M0054.
    VERSIONSTRING=$(</etc/version)
    M0052SUBSTRING="M0052"
    if [[ "$VERSIONSTRING" == *"$M0052SUBSTRING"* ]]; then
        PLATFORM="M0052"
    else
        PLATFORM="M0054"
    fi
fi

# We can only run on M0052 or M0054 so exit with error if that is not the case
if [ $PLATFORM = "M0052" ]; then
    echo "Running on M0052"
elif [ $PLATFORM = "M0054" ]; then
    echo "Running on M0054"
else
    echo "Error, cannot determine platform!"
    exit 1
fi

uorb start
muorb start

# In order to just exit after starting the uorb / muorb modules define
# the environment variable MINIMAL_PX4. (e.g. export MINIMAL_PX4=1)
# This is useful for testing / debug where you may want to start drivers
# and modules manually from the px4 command shell
if [ ! -z $MINIMAL_PX4 ]; then
    echo "Running minimal script"
    exit 0
fi

# Sleep a little here. A lot happens when the uorb and muorb start
# and we need to make sure that it all completes successfully to avoid
# any possible race conditions.
sleep 1

# Start logging immediately and use timestamps for log files when possible
# logger start -e -t
logger start -t

# IMU (accelerometer / gyroscope)
# Start this first because it gets the high rate interrupts coming in to the
# DSP. Without this the DSP will oversleep and miss critical timeouts.
# TODO: Why is that the case?
qshell icm42688p start -s

sleep 1

# Load in all of the parameters that have been saved in the file
param load

# We do not change the value of SYS_AUTOCONFIG but if it does not
# show up as used then it is not reported to QGC and we get a
# missing parameter error.
param touch SYS_AUTOCONFIG

# Start all of the device drivers on DSP

# Magnetometer
qshell ist8310 start -R 10 -X -b 1

# LED driver for the Pixhawk 4 GPS module
# Older units have i2c address 0x39 (57) and newer ones 0x38 (56)
# M0054 only supports the newer one. M0052 can support either.
if [ $PLATFORM = "M0052" ]; then
    qshell rgbled_ncp5623c start -X -b 1 -f 400 -a 57
fi
qshell rgbled_ncp5623c start -X -b 1 -f 400 -a 56

# Barometer
qshell icp10100 start -I -b 5

# ESC driver
qshell modalai_esc start
qshell mixer load /dev/uart_esc quad_x.main.mix

# APM power monitor
qshell voxlpm start -X -b 2

# On M0052 the GPS and RC drivers run on the apps processor
if [ $PLATFORM = "M0052" ]; then
    # Pixhawk 4 GPS module
    gps start -d /dev/ttyHS2

    # RC input may be coming via either an external M0065 (aka px4io) module
    # or a directly attached Spektrum receiver. First see if the M0065 is detected.
    # This is only applicable for M0052. M0065 is not yet supported on M0054.
    px4io detect
    PX4IO_STATUS=$?
    echo "PX4IO detect returned value $PX4IO_STATUS"
    if [ $PX4IO_STATUS -eq 0 ]; then
      echo "Found M0065, starting px4io"
      px4io start
    else
      echo "M0065 not detected, starting Spektrum RC driver"
      spektrum_rc start -d /dev/ttyHS1
    fi
# On M0054 the GPS and RC drivers run on SLPI DSP
else
    # Pixhawk 4 GPS module
    # Only the newer Holybro unit is supported on M0054
    qshell gps start -d 7 -b 115200

    # Spektrum RC receiver
    qshell spektrum_rc start -d 8
fi


sleep 1

# Start all of the processing modules on DSP

qshell sensors start
qshell ekf2 start
qshell mc_pos_control start
qshell mc_att_control start
qshell mc_rate_control start
qshell mc_hover_thrust_estimator start
qshell land_detector start multicopter

sleep 1

# Start all of the processing modules on the applications processor

rc_update start

dataman start

navigator start

commander start
commander mode manual

# This is needed for altitude and position hold modes
flight_mode_manager start

# Configure a primary mavlink instance for QGC communications
# Look for a file called qgc-ip.cfg containing a QGC IP address
# and, optionally, a port number
QGC_IP=`find-qgc-address`
QGC_PORT=`find-qgc-address -p`
if [ -z "$QGC_IP" ]; then
  echo "No QGC IP address found. Configuring Mavlink for broadcast"
  param set MAV_BROADCAST 1
  mavlink start -x -u 14557 -r 40000
else
  echo "Found QGC IP address $QGC_IP. Disabling Mavlink broadcast"
  param set MAV_BROADCAST 0
  mavlink start -x -u 14557 -r 40000 -t $QGC_IP -o $QGC_PORT
fi

# Configure a second mavlink instance for onboard messages (e.g. VIO and VOA)
mavlink start -u 14556 -t 127.0.0.1 -n lo -m custom

sleep 1

mavlink stream -u 14557 -s HIGHRES_IMU -r 5
mavlink stream -u 14557 -s ATTITUDE -r 5
mavlink stream -u 14557 -s RC_CHANNELS -r 20

sleep 1

# Start up the IMU server to support VIO
imu_server start

mavlink boot_complete
